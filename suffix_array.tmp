#include <iostream>
#include <limits>
#include <algorithm>

#include <vector>


struct CmpInfo
{
	unsigned short Rank;
	unsigned short RankNext;
	unsigned Index;

	bool operator< (const CmpInfo& o) const { return (Rank < o.Rank || (Rank == o.Rank && RankNext < o.RankNext)); }
	bool operator!=(const CmpInfo& o) const { return (Rank != o.Rank || RankNext != o.RankNext); }

	static bool index_less(const CmpInfo& a, const CmpInfo& b) { a.Index < b.Index; }
};


int main(int, char**)
{
	std::string str = "abaab";//"abcxeabcye";
	unsigned n = str.length();

	std::cout << "Input: " << str << std::endl;

	// Init ranks
	typedef	std::vector<unsigned> ranks_t;

	ranks_t ranks[2];
	unsigned iRanksPrev = 0, iRanksCur = 1;
	ranks[iRanksPrev].resize(n);
	ranks[iRanksCur ].resize(n);
	for(unsigned i = 0; i < n; i++)
		ranks[iRanksPrev][i] = str[i] - 'a';

	// Compare loop
	std::vector<CmpInfo> info(n);

	// Compare char pairs separated with the offset
	unsigned short maxRank = std::numeric_limits<unsigned short>::max();
	for(unsigned offset = 1; offset < n; offset *= 2, std::swap(iRanksPrev, iRanksCur))
	{
		const ranks_t ranksPrev = ranks[iRanksPrev];
			  ranks_t ranksCur  = ranks[iRanksCur ];

		// Update comparison info
		for(unsigned i = 0; i < n; i++)
		{
			info[i].Rank = ranksPrev[i];
			if(i + offset < n)
				info[i].RankNext = ranksPrev[i + offset];
			else
				info[i].RankNext = maxRank;
			info[i].Index = i;
		}

		std::sort(info.begin(), info.end());

		// Re-rank
		ranksCur[info[0].Index] = 0;
		for(unsigned i = 1, r = 0; i < n; i++)
		{
			if(info[i - 1] != info[i])
				r++;
			ranksCur[info[i].Index] = r;
		}
	}

	std::sort(info.begin(), info.end(), CmpInfo::index_less);
	for(unsigned i = 0; i < n; i++)
		std::cout << (str.c_str() + info[i].Index) << std::endl;
}

